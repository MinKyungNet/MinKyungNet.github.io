---
layout: post
title: "지수 가중 이동 평균 이해하기"
tags: [Exponentially Weighted Average]
categories: [Improving deep neural networks]
---

# 학습 목표
지수 가중 이동 평균에 대해서 더 깊게 알 수 있다.

# 핵심 키워드
지수 가중 이동 평균(Exponentially Weighted Average)

# 학습 내용
* b = 0.9 일때, 어떤 시점에서 앞서 나온 지수 가중 이동 평균 식을 하나의 값으로 정리하여 표현하게 되면 아래와 같습니다.
  * v100 = 0.1세타100 + 0.1 * 0.9 * 세타99 + 0.1 * 0.9^2 * 세타89 + ...
* 이를 그림으로 표현하면 지수적으로 감소하는 그래프입니다.(v100을 기준으로 보았을 때), 그 기유는 v100은 각각의 요소에 지수적으로 감소하는 요소를 곱해서 더한것이기 때문입니다.   
* 얼마의 기간이 이동하면서 평균이 구해졌는가?는 아래의 식으로 대략적으로 구할 수 있습니다.
  * b = (1 - e)라고 정의하면
  * (1 - e)^n = 1/e를 만족하는 n이 그 기간이 되는데, 보통 1/e으로 구할 수 있습니다.
* 지수 가중 이동 평균의 장점은 구현시 아주 적은 메모리를 사용한다는 것입니다.

# 인트로
지난 글에서는 지수가중평균에 대해 얘기했습니다.        
신경망 훈련에 사용하는 몇 가지 최적화 알고리즘의 주요 구성요소가 될 것입니다.          
이번 비디오에서는 이 알고리즘이 하는 일에 대해서 더 깊게 알아보고 싶습니다.          
 
# b에 따라 달라지는 지수가중평균 그래프
![image](https://user-images.githubusercontent.com/50114210/65562802-9cbec000-df82-11e9-8dde-a24c225c8fde.png)      
이 공식이 지수가중평균을 구현하는데 주요한 공식인 것을 기억하시나요?         
β가 0.9와 같은 경우 빨간색 곡선을 얻게 됩니다.         
1에 가까운 0.98의 경우 초록색 곡선을 얻게 됩니다.        
0.5로 작은 값의 경우 노란색 곡선을 얻게 됩니다.        

# 지수가중평균 공식
![image](https://user-images.githubusercontent.com/50114210/65565613-5e79ce80-df8b-11e9-9c62-11fb07479c84.png)   
일일 기온의 평균을 계산하는 방법에 대해 수학적으로 더 알아봅시다.         
여기 공식이 다시 나옵니다. β를 0.9로 설정합시다. 이를 이용해 몇 가지 식을 더 작성하겠습니다.        
이것을 구현할 때 t는 0부터 1, 2, 3으로 증가하는데 분석을 위해 t가 감소하는 방향으로 식을 작성하겠습니다.          

# 연쇄적으로 계산되는 지수가중평균
![image](https://user-images.githubusercontent.com/50114210/65565655-80735100-df8b-11e9-9d48-d22bebefe075.png)    
여기 이 첫 번째 식을 살펴봅시다. V_100이 무엇인지 알아봅시다. 두 항의 위치를 바꾸겠습니다.             
0.1 곱하기 θ_100 더하기 0.9 곱하기 V_99가 V_100의 값이 됩니다.           
그럼 V_99의 값은 무엇일까요? 위 식에서 가져오도록 하겠습니다.          
이것은 두 항을 바꾼 0.1*θ_99 + 0.9*V_98이 됩니다.           
V_98 역시 이 위의 식을 대입해 0.1*θ_98 + 0.9*V_97입니다. 이런 식으로 계속됩니다.            
이 모든 항을 다 곱하면 V_100는 0.1*θ_100 더하기 θ_99의 계수를 보면 0.1 곱하기 0.9 곱하기 θ_99입니다.             
이제 θ_98의 계수를 살펴보면 0.1 * 0.9 * 0.9입니다.           

# 식을 전개
![image](https://user-images.githubusercontent.com/50114210/65565677-94b74e00-df8b-11e9-9e7b-8fb137c41503.png)     
따라서 식을 확장하면 0.1*(0.9)^2*θ_98이 됩니다.          
식을 계속 확장하면 그 다음은 0.1*(0.9)^3*θ_97 더하기 0.1*(0.9)^4*θ_96 + ... 입니다.             
따라서 이것이 가중치의 합, 즉 θ_100의 가중치의 평균입니다.               
이것은 현재 온도이고 한 해의 100일째인 V_100을 찾고 있습니다.            
이것은  θ_100,  θ_99,  θ_98,  θ_97, ... 의 합으로 되어 있습니다.          

# 지수가중평균의 그래프
![image](https://user-images.githubusercontent.com/50114210/65565791-ecee5000-df8b-11e9-84eb-671d216d3907.png)    
이것을 그림으로 나타내는 한 가지 방법은 몇 일간의 온도가 있다고 했을 때,            
여기가 θ축이고 이 쪽은 t축입니다 θ_100는 어떤 값을 갖고, θ_99도 어떤 값을 갖게 될 것입니다.         
t가 100일 때, 99일 때, 98일 때의 θ를 표시한 것입니다.           
따라서 몇 일간의 온도를 표시한 것입니다. 우리가 볼 수 있는 것은 지수적으로 감소하는 함수입니다.          
0.1에서 시작해 0.9*0.1 (0.9)^2*0.1 따라서 지수적으로 감소하는 함수입니다.            
V_100을 구하는 과정은 이 두 함수 간에 요소별 곱셈을 해서 더하는 것입니다.            
이 값을 취해서 θ_100 * 0.1 θ_99*0.1*0.9 이런 식으로           
일일 온도에 지수적으로 감소하는 함수를 곱해주고 모두 더합니다.          
그럼 그 값이 V_100이 됩니다 이 앞에 곱해지는 계수들을 모두 더하면 1 또는 1에 가까운 값이 됩니다.               
이들에 의해 지수가중평균이 됩니다. 

# b에 따라 이전에 영향을 받는 범위가 달라진다
![image](https://user-images.githubusercontent.com/50114210/65565712-aef12c00-df8b-11e9-88e6-e34d3b2ef53d.png)    
얼마나 많은 날들이 평균적인 온도가 되는지 궁금하실 겁니다.            
0.9^10이 0.35와 대략적으로 같고 이 값은 1/e, 즉 많은 자연로그의 밑과 대략적으로 같습니다.             
더 일반적으로 (1-ε)이 있다면 이 예시에서 ε은 0.1이 되고 (1-ε)은 0.9가 됩니다.              
(1-ε)^(1/ε)은 대략적으로 1/e와 같습니다 0.3 또는 0.35입니다.           
다른 말로 온도가 감소하기까지 즉 1/3이 되기까지 약 10일이 걸립니다.            
따라서 이런 이유때문에 β가 0.9와 같을 때 만약 지난 10일간의 온도에만
초점을 맞춰 가중평균을 계산한다면 10일 뒤에는 가중치가 현재 날짜의 가중치의 1/3로 줄어듭니다.           
그와 반대로 β가 0.98이라면 이 값이 매우 작아지려면 0.98의 몇 제곱이 필요할까요?           
0.98^50가 대략적으로 1/e와 같습니다.  처음 50일 동안의 1/e보다 가중치는 더 커질 것입니다.          
감소는 가파르게 일어날 것입니다. 따라서 직관적으로 50일의 온도의 평균은 더 급격히 빠릅니다.            
왜냐하면 이 예시에서 ε은 0.02이기기 때문입니다. 따라서 1/ε은 50과 같습니다.              
이것은 1/(1-β)와도 대략적으로 같습니다. 여기서 ε은 1-β입니다.          
평균적인 온도가 몇 일 정도가 될지에 관한 상수를 알려줍니다.         
그러나 이것은 관습적으로 쓰이는 것이지 수학 공식은 아닙니다.           

# 손으로 계산
![image](https://user-images.githubusercontent.com/50114210/65565814-0099b680-df8c-11e9-84b7-2357dedc517e.png)    
이제 실제로 어떻게 구현할지를 알아봅시다.         
v_0를 0으로 초기화합니다. 첫째 날에는 v_1, 둘째 날에는 v_2, 이런 식으로 계속됩니다.          
v_0, v_1, v_2, ...를 별개의 변수로 취급합니다. 실제로 구현할 때는 v를 0으로 초기화합니다.          
그리고 첫째 날에는 v를 β*v + (1--β)θ_1으로 설정합니다.        
다음 날에는 v를 β*v + (1--β)θ_2로 설정합니다.           
가끔 v에 아래 첨자 θ를 한 표기법을 사용하기도 합니다.           
v가 θ를 매개변수로 하는 지수가중평균을 계산한다는 것을 나타내기 위해서요.           

# 반복문으로 구현
![image](https://user-images.githubusercontent.com/50114210/65565830-114a2c80-df8c-11e9-80bb-5ba006603f7f.png)   
이것은 반복문으로 나타내면 v_θ를 0으로 설정하고 각각의 날짜마다 다음 θ_t를 얻고,          
그리고 v_θ는 β*v_θ + (1-β)θ_t로 업데이트됩니다. 
이렇게 지수평균을 얻는 식의 장점은 아주 적은 메모리를 사용한다는 것입니다.          
이 실수 하나만을 컴퓨터 메모리에 저장하고,             
가장 최근에 얻은 값을 이 식에 기초해 덮어쓰기만 하면 되니까요.         
한 줄의 코드만 작성하면 되서 효율적입니다.           
그리고 지수가중평균을 계산하기 위해 하나의 실수를 저장하는 메모리만 필요합니다.           
평균을 계산하는 가장 정확하고 최선의 방법은 아닙니다.           
명시적으로 지난 10일 또는 50일 간의 온도를 더하고,           
10이나 50으로 나누는 것이 더 나은 추정치를 제공합니다.         
그러나 그렇게 하는 방법은 더 많은 메모리를 필요로 합니다.        
그리고 더 복잡한 구현이라 컴퓨터적으로 많은 비용이 필요합니다.           
따라서 다음 글에서 몇 가지 예제에 나오는 많은 변수의 평균을 계산하는 경우에는,             
이것이 컴퓨터 계산 비용과 메모리 효율 측면에서 더 효율적입니다.             
머신러닝에서 이 방법을 많이 사용하는 이유입니다.        
한 줄의 코드가 갖는 이점도 분명이 있을 것이구요.       

# 아웃트로
이제 지수가중평균을 구하는 방법을 배웠습니다.          
편향 보정이라고 불리는 하나의 기술적인 세부 사항이 남아 있습니다.         
다음 글에서 살펴봅시다. 그럼 일반적인 경사 하강법보다             
더 나은 최적화 알고리즘을 구현하는데 사용할 수 있을 것입니다.         

