---
layout: post
title: "머신 비전 프로그래밍 : 히스토그램"
tags: [Histogram, Sampling, Quantization, HSI]
categoires: [Computer Vision]
---
# 디지털 영상의 획득과 표현
![image](https://user-images.githubusercontent.com/50114210/64515020-bfb46780-d326-11e9-9ac7-7ad00a70a3c3.png)    
카메라는 사람의 눈을 많이 본떠서 만들었다.   
* 들어오는 빛의 양에 따라 이완 / 수축하는 홍채 근육에 의해 작아지고 커지고하는 동공     
아이리스에 따라 조리개가 움직임(카메라 잘 모름 무식 주의)    
*눈의 근육에 따라 얇아지고 두까워지는 수정체     
멀어졌다 가까워졌다 하는 렌즈

# 디지털 영상의 획득과 표현
![image](https://user-images.githubusercontent.com/50114210/64515314-52550680-d327-11e9-8e88-d38b65c7cb24.png)    
아날로그 신호를 디지털 신호로 바꾸기 위해선 두 가지의 과정이 필요하다.
1. 샘플링(Sampling)
2. 양자화(Quantization)
아날로그 신호는 연속적이고 디지털 신호는 분산적이기 때문에 신호의 변환을 위해서는 아날로그의 일정 부분을 잘라내야한다.     
### 샘플링
![저퀄 죄송 ㅎ](https://user-images.githubusercontent.com/50114210/64515898-6c431900-d328-11e9-8f56-2dd3e78e3f12.png)    
샘플링을 많이 한다는 것은 같은 아날로그 데이터에 얼마나 많은 픽셀을 사용한다는 뜻이다.   
위의 그림에서 꽃을 2 by 2로 표현한 것과 8 by 8로 표현한 것은 분명한 차이가 있다.
샘플링의 정도를 높일 수록 더 아날로그 신호같은 데이터를 만들 수 있을 것이다.
### 양자화
![image](https://user-images.githubusercontent.com/50114210/64516208-0b681080-d329-11e9-86f0-445b050c02c0.png)    
양자화는 한 픽셀에 몇 비트를 사용할 것인가를 나타낸다.   
만약 한 픽셀에 1비트를 사용한다고 하면 하양과 검정만 표현할 수 있겠지만,     
한 픽셀에 24비트를 사용한다고 하면 눈으로 볼 수 있는 아주 많은 색들을 표현할 수 있을 것이다.   
그래서 샘플링과 양자화의 정도를 높일 수록 변환 수준은 좋아지겠지만 신호에 대한 용량이 그만큼 커지게 된다.    
#### 의료영상
일반적인 컬러 이미지는 8비트 체계를 사용하는 경우가 많지만,     
아주 디테일한 정보도 중요한 의료영상에서는 10비트 12비트 체계를 사용하기도 한다.

### 영상 좌표계
![image](https://user-images.githubusercontent.com/50114210/64516341-51bd6f80-d329-11e9-83d8-0f23f722929d.png)    
일반적으로 영상에서는 왼쪽 위를 (0, 0) 원점으로 본다.    
표현은 f(x, y) 혹은 f(y, x)등으로도 한다.
보통 행렬을 표현할 때 M행 N열을 가진 행렬이라고 많이 표현하는데,    
이미지를 표현할 때는 행렬의 표현방법을 그대로 받아서, 가로(N) 세로(M)로 표현하는 경우도 있지만
사람 헷갈리게 가로(M), 세로(N)로 표현하는 경우도 있으니 주의해야한다.    
만약 640 * 480의 이미지가 있다면 원점과 가장 멀리떨어져 있는 맨 오른쪽 아래의 픽셀은 f(479, 639) 혹은 f(639, 479)로 표현할 수 있다.    
#### 컬러 영상
컬러 영상은 한 픽셀을 표현하는데 여러개의 비트를 사용한다.   
만약 RGB당 8비트씩을 사용한다고 하면 한 픽셀에 2^24개의 색상을 표현할 수 있게 된다.    
r, g, b값들을 모니터에 전달하여 어느정도의 비율로 밝기를 조절할 것인지 정해준다.

### 영상 표시 방법
![image](https://user-images.githubusercontent.com/50114210/64516920-3ef76a80-d32a-11e9-935b-63454e19b6f7.png)
1. 영상 : 숫자가 크면 밝게, 낮으면 어둡게
2. 배열 : 우리는 배열 표기법에 익숙해져야한다. 255는 화이트 0은 블랙
3. 지형 : x, y 축에서 화소 값이 큰 곳은 높게 작은 곳은 낮게

# 히스토그램
![image](https://user-images.githubusercontent.com/50114210/64517281-f68c7c80-d32a-11e9-8ac2-c3ee796cdc4c.png)    
히스토그램은 막대그래프이다. 영상의 해당하는 화소가 몇개 있는지 표현해주는 것.    
위의 그래프에서 가로는 화소 세로는 빈도수를 나타낸다. 


### 히스토그램 계산
```python
h = [0 for i in range(255)]
for h in range(이미지의 세로):
  for w in range(이미지의 가로):
    h[image[h * 이미지의 세로 + w]] += 1
```
히스토그램을 구축하기 위해서는 영상의 픽셀을 모두 순회하면서 픽셀값에 해당하는    
히스토그램의 인덱스값을 1 증가시켜주면 된다.


### 히스토그램 정규화
```python
for i in range(이미지의 가로 * 세로):
  h[i] = h[i] / (이미지의 가로 * 세로)
```
빈도는 보통은 정규화하는 과정을 거쳐서 확률로 쓰기도 한다.    
확률로 쓰기 위해서는 히스토그램 값을 영상의 해상도로 나눠준다.     
히스토그램값을 정규화해준다면(확률로 나타낸다면) 해당하는 비율로 표현될 수 있을 것이다.    
정규화를 해줘서 빈도엿던 것을 확률인 확률 밀도함수(PDF, probability density function)로 변경해주는 것이다.    

### 히스토그램의 용도
히스토그램을 구하는 이유는 현재 영상이 어떤 상태인지 분석하기 위함이다.    

#### 사진 1
![image](https://user-images.githubusercontent.com/50114210/64517652-bd084100-d32b-11e9-9808-a971c0d02ddc.png)     
이 사진은 영상의 화소의 개수, 확률이 아니라 빈도로 히스토그램을 표현했다.    
사진으로 정말 다양한 색을 표현할 수 있는데도 어두운 영상이 되었고, 결과적으로 보기좋은 사진이 아니다.   

#### 사진 2
![image](https://user-images.githubusercontent.com/50114210/64517843-0eb0cb80-d32c-11e9-9e2f-338a20670c51.png)     
이 사진은 히스토그램이 비교적 균등하게 나와서 보기 좋다.

#### 사진 3
![image](https://user-images.githubusercontent.com/50114210/64517902-2be59a00-d32c-11e9-878b-ef6ee7d22c56.png)    
달이 굉장히 밝아서 달에 해당하는 화소값과 나머지 부분으로 나눌 수 있다.    
자세히 보면 255부분에 히스토그램이 조금 튀어나온 것을 볼 수 있다.    
이런 상태의 사진을 바이모달이라고한다. 봉오리가 두개라는 것은 한 봉오리는 배경, 다른 봉오리는 전경이라고 할 수 있다.    
전경과 배경을 구분해주기위해서는 히스토그램을 적절히 나누는 임계치 값이 중요한데,    
곤잘레스 알고리즘을 사용하면 적절한 임계치 값을 자동으로 결정할 수 있다.    

### 히스토그램 평활화
![image](https://user-images.githubusercontent.com/50114210/64518182-af06f000-d32c-11e9-9a18-04fd96f8fc25.png)    
히스토그램을 평활화하는 이유는 히스토그램을 고르게 분포시켜서 보기 좋은 사진을 만드는 것이다.    

```python
# 히스토그램 계산후
AHisto = [0 for i in range(255)]
AHisto[0] = Histo[0]
for i in range(1, 이미지 해상도(가로 * 세로)):
  AHisto[i] += AHisto[i-1] + Histo[i]
  
for i in range(len(AHisto)):
  AHisto[i] = AHisto[i] * 최대 화소값 / 이미지 사이즈(가로 * 세로)
  
for h in range(세로):
  for w in range(가로):
    image[h * 세로 + w] = AHisto[image[h * 세로 + w]]
```

#### 주의
![image](https://user-images.githubusercontent.com/50114210/64518954-2b4e0300-d32e-11e9-88e4-5203e93cbad5.png)    
히스토그램을 평활화한다고 꼭 이미지가 보기 좋아지는 것은 아니다.

### 영역 검출
#### 달 영역을 범위로 검출해보자
![image](https://user-images.githubusercontent.com/50114210/64533879-601e8200-d34f-11e9-9a85-44adfb0939bb.png)    
어두운 하늘에 달이 떠있다고 생각해보자.    
영상에서 달에 해당되는 영역을 검출하고 싶다면 달이 존재하는 구간을 정해야한다.    
만약 달이 230에서 255사이의 화소값에 존재한다면, 다른 사진이 들어와도 화소값들을 하나하나 검사해서 달 영역을 검출할 수 있게된다.
어떻게 보면 이진화와 굉장히 비슷하다.      
임계값으로 기준을 잡을 수도 있고, 하나의 범위로 기준을 잡을 수도 있고, 여러개의 범위를 기준으로 잡을 수도 있다.

#### 가장 확률이 높은 값
![image](https://user-images.githubusercontent.com/50114210/64534265-1edaa200-d350-11e9-8878-b758c2216094.png)
달에 해당하는 히스토그램을 확대했더니 240부터 255까지의 값이 나왔다고하자.      
그렇다고 히스토그램의 모든 값이 달이라고 하기에는 무리가 있으므로    
믿을만한 일정범위 이상인 경우에만 달이라고 간주해야할 것이다.    
여기서 매핑함수를 사용하는데, 입력으로 픽셀값을 넣어주면 달인지 아닌지를 출력한다.    

#### 얼굴 영역을 범위로 검출해보자
![image](https://user-images.githubusercontent.com/50114210/64534523-91e41880-d350-11e9-9406-c9ad3ba44dc6.png)    
얼굴은 보다싶히 컬러 영상이다. 보통 RGB체계를 많이 사용하지만 얼굴 영역 검출을 위해서는 HSI모델이 더 적합하다.    
오른쪽의 그래프를 보면 알겠지만 H와 S가 0에 가까운 부분이 얼굴영역일 확률이 높다.
2차원 상에서 높이 튀어나와있다면 많은 픽셀이 그 값에 해당한다는 뜻이기 때문이다.


